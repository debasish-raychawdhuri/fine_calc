use crate::ast::{Expr, BinOp, UnaryOp, Span, Spanned, SpannedExpr};

grammar;

// Top-level entry point: allows lambda or regular expression
// Lambda can only appear at top level, in parens, in index [], in fold {}, or as tuple/array element
pub Expr: SpannedExpr = {
    LambdaExpr,
    TopExpr,
};

// Lambda definitions - NOT part of the normal expression hierarchy
// This prevents things like -|x|(x) or |x|(x) + 1
LambdaExpr: SpannedExpr = {
    // Single param: |x|(body)
    <l:@L> "|" <p:Ident> "|" "(" <body:Expr> ")" <r:@R> => {
        Spanned::new(Expr::Lambda { params: vec![p.to_string()], body: Box::new(body) }, Span::new(l, r))
    },
    // Multi param: |x,y|(body)
    <l:@L> "|" <first:Ident> "," <rest:Comma<Ident>> "|" "(" <body:Expr> ")" <r:@R> => {
        let mut params = vec![first.to_string()];
        params.extend(rest.iter().map(|s| s.to_string()));
        Spanned::new(Expr::Lambda { params, body: Box::new(body) }, Span::new(l, r))
    },
};

TopExpr: SpannedExpr = {
    <l:@L> <left:TopExpr> "||" <right:AndExpr> <r:@R> => {
        Spanned::new(Expr::BinOp(Box::new(left), BinOp::Or, Box::new(right)), Span::new(l, r))
    },
    AndExpr,
};

AndExpr: SpannedExpr = {
    <l:@L> <left:AndExpr> "&&" <right:CmpEq> <r:@R> => {
        Spanned::new(Expr::BinOp(Box::new(left), BinOp::And, Box::new(right)), Span::new(l, r))
    },
    CmpEq,
};

CmpEq: SpannedExpr = {
    <l:@L> <left:CmpEq> "==" <right:CmpRel> <r:@R> => {
        Spanned::new(Expr::BinOp(Box::new(left), BinOp::Eq, Box::new(right)), Span::new(l, r))
    },
    <l:@L> <left:CmpEq> "!=" <right:CmpRel> <r:@R> => {
        Spanned::new(Expr::BinOp(Box::new(left), BinOp::Ne, Box::new(right)), Span::new(l, r))
    },
    CmpRel,
};

CmpRel: SpannedExpr = {
    <l:@L> <left:CmpRel> ">=" <right:Additive> <r:@R> => {
        Spanned::new(Expr::BinOp(Box::new(left), BinOp::Ge, Box::new(right)), Span::new(l, r))
    },
    <l:@L> <left:CmpRel> "<=" <right:Additive> <r:@R> => {
        Spanned::new(Expr::BinOp(Box::new(left), BinOp::Le, Box::new(right)), Span::new(l, r))
    },
    <l:@L> <left:CmpRel> ">" <right:Additive> <r:@R> => {
        Spanned::new(Expr::BinOp(Box::new(left), BinOp::Gt, Box::new(right)), Span::new(l, r))
    },
    <l:@L> <left:CmpRel> "<" <right:Additive> <r:@R> => {
        Spanned::new(Expr::BinOp(Box::new(left), BinOp::Lt, Box::new(right)), Span::new(l, r))
    },
    Additive,
};

Additive: SpannedExpr = {
    <l:@L> <left:Additive> "+" <right:Multiplicative> <r:@R> => {
        Spanned::new(Expr::BinOp(Box::new(left), BinOp::Add, Box::new(right)), Span::new(l, r))
    },
    <l:@L> <left:Additive> "-" <right:Multiplicative> <r:@R> => {
        Spanned::new(Expr::BinOp(Box::new(left), BinOp::Sub, Box::new(right)), Span::new(l, r))
    },
    Multiplicative,
};

Multiplicative: SpannedExpr = {
    <l:@L> <left:Multiplicative> "**" <right:Power> <r:@R> => {
        Spanned::new(Expr::BinOp(Box::new(left), BinOp::TensorProduct, Box::new(right)), Span::new(l, r))
    },
    <l:@L> <left:Multiplicative> "*" <right:Power> <r:@R> => {
        Spanned::new(Expr::BinOp(Box::new(left), BinOp::Mul, Box::new(right)), Span::new(l, r))
    },
    <l:@L> <left:Multiplicative> "/" <right:Power> <r:@R> => {
        Spanned::new(Expr::BinOp(Box::new(left), BinOp::Div, Box::new(right)), Span::new(l, r))
    },
    Power,
};

Power: SpannedExpr = {
    <l:@L> <base:Unary> "^" <exp:Power> <r:@R> => {
        Spanned::new(Expr::BinOp(Box::new(base), BinOp::Pow, Box::new(exp)), Span::new(l, r))
    },
    Unary,
};

Unary: SpannedExpr = {
    <l:@L> "-" <u:Unary> <r:@R> => {
        Spanned::new(Expr::UnaryOp(UnaryOp::Neg, Box::new(u)), Span::new(l, r))
    },
    <l:@L> "!" <u:Unary> <r:@R> => {
        Spanned::new(Expr::UnaryOp(UnaryOp::Not, Box::new(u)), Span::new(l, r))
    },
    Postfix,
};

Postfix: SpannedExpr = {
    // Index: arr[idx] - idx can be lambda for filtering
    <l:@L> <base:Postfix> "[" <idx:Expr> "]" <r:@R> => {
        Spanned::new(Expr::Index(Box::new(base), Box::new(idx)), Span::new(l, r))
    },
    // Fold: array @ init { lambda }
    <l:@L> <arr:Postfix> "@" <init:Unary> r"\{" <lam:Expr> r"\}" <r:@R> => {
        Spanned::new(Expr::Fold { array: Box::new(arr), init: Box::new(init), lambda: Box::new(lam) }, Span::new(l, r))
    },
    Atom,
};

Comma<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T> => {
        v.push(e);
        v
    }
};

CommaSep<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T?> => match e {
        Some(e) => { let mut v = v; v.push(e); v }
        None => v
    }
};

Atom: SpannedExpr = {
    Num,
    // Tuple literal: (a, b) or (a, b, c, ...) - elements can be lambdas
    <l:@L> "(" <first:Expr> "," <rest:Comma<Expr>> ")" <r:@R> => {
        let mut elems = vec![first];
        elems.extend(rest);
        Spanned::new(Expr::Tuple(elems), Span::new(l, r))
    },
    // Grouping parentheses - can contain lambda
    "(" <e:Expr> ")" => e,
    // Range: [n] creates array 0..n
    <l:@L> "[" <e:TopExpr> "]" <r:@R> => {
        Spanned::new(Expr::Range(Box::new(e)), Span::new(l, r))
    },
    // Array literal: {1, 2, 3} - elements can be lambdas
    <l:@L> r"\{" <elems:Comma<Expr>> r"\}" <r:@R> => {
        Spanned::new(Expr::Array(elems), Span::new(l, r))
    },
    // Builtin function call or user function call - argument can be lambda
    <l:@L> <name:Ident> "(" <arg:Expr> ")" <r:@R> => {
        let builtins = ["sin", "cos", "tan", "asin", "acos", "atan",
                        "sinh", "cosh", "tanh", "asinh", "acosh", "atanh",
                        "sqrt", "abs", "ln", "log2", "log10", "exp",
                        "floor", "ceil", "round"];
        if builtins.contains(&name) {
            Spanned::new(Expr::BuiltinCall(name.to_string(), Box::new(arg)), Span::new(l, r))
        } else {
            Spanned::new(Expr::Call(name.to_string(), Box::new(arg)), Span::new(l, r))
        }
    },
    // Variable reference
    <l:@L> <name:Ident> <r:@R> => {
        Spanned::new(Expr::Ident(name.to_string()), Span::new(l, r))
    },
};

Num: SpannedExpr = <l:@L> <s:r"[0-9]+(\.[0-9]+)?"> <r:@R> => {
    Spanned::new(Expr::Scalar(s.parse().unwrap()), Span::new(l, r))
};

Ident: &'input str = <s:r"[a-zA-Z_][a-zA-Z0-9_]*"> => s;
