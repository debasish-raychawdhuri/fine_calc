use crate::ast::{Expr, BinOp, UnaryOp};

grammar;

pub TopExpr: Expr = {
    <l:TopExpr> "||" <r:AndExpr> => Expr::BinOp(Box::new(l), BinOp::Or, Box::new(r)),
    AndExpr,
};

AndExpr: Expr = {
    <l:AndExpr> "&&" <r:CmpEq> => Expr::BinOp(Box::new(l), BinOp::And, Box::new(r)),
    CmpEq,
};

CmpEq: Expr = {
    <l:CmpEq> "==" <r:CmpRel> => Expr::BinOp(Box::new(l), BinOp::Eq, Box::new(r)),
    <l:CmpEq> "!=" <r:CmpRel> => Expr::BinOp(Box::new(l), BinOp::Ne, Box::new(r)),
    CmpRel,
};

CmpRel: Expr = {
    <l:CmpRel> ">=" <r:Additive> => Expr::BinOp(Box::new(l), BinOp::Ge, Box::new(r)),
    <l:CmpRel> "<=" <r:Additive> => Expr::BinOp(Box::new(l), BinOp::Le, Box::new(r)),
    <l:CmpRel> ">" <r:Additive> => Expr::BinOp(Box::new(l), BinOp::Gt, Box::new(r)),
    <l:CmpRel> "<" <r:Additive> => Expr::BinOp(Box::new(l), BinOp::Lt, Box::new(r)),
    Additive,
};

Additive: Expr = {
    <l:Additive> "+" <r:Multiplicative> => Expr::BinOp(Box::new(l), BinOp::Add, Box::new(r)),
    <l:Additive> "-" <r:Multiplicative> => Expr::BinOp(Box::new(l), BinOp::Sub, Box::new(r)),
    Multiplicative,
};

Multiplicative: Expr = {
    <l:Multiplicative> "**" <r:Power> => Expr::BinOp(Box::new(l), BinOp::TensorProduct, Box::new(r)),
    <l:Multiplicative> "*" <r:Power> => Expr::BinOp(Box::new(l), BinOp::Mul, Box::new(r)),
    <l:Multiplicative> "/" <r:Power> => Expr::BinOp(Box::new(l), BinOp::Div, Box::new(r)),
    Power,
};

Power: Expr = {
    <base:Unary> "^" <exp:Power> => Expr::BinOp(Box::new(base), BinOp::Pow, Box::new(exp)),
    Unary,
};

Unary: Expr = {
    "-" <u:Unary> => Expr::UnaryOp(UnaryOp::Neg, Box::new(u)),
    "!" <u:Unary> => Expr::UnaryOp(UnaryOp::Not, Box::new(u)),
    Postfix,
};

Postfix: Expr = {
    <base:Postfix> "[" <idx:TopExpr> "]" => Expr::Index(Box::new(base), Box::new(idx)),
    Atom,
};

Comma<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T> => {
        v.push(e);
        v
    }
};

CommaSep<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T?> => match e {
        Some(e) => { let mut v = v; v.push(e); v }
        None => v
    }
};

Atom: Expr = {
    Num,
    // Lambda: |x|(body)
    "|" <p:Ident> "|" "(" <body:TopExpr> ")" => {
        Expr::Lambda { params: vec![p.to_string()], body: Box::new(body) }
    },
    // Lambda: |(x,y)|(body)
    "|" "(" <params:Comma<Ident>> ")" "|" "(" <body:TopExpr> ")" => {
        Expr::Lambda { params: params.iter().map(|s| s.to_string()).collect(), body: Box::new(body) }
    },
    // Tuple literal: (a, b) or (a, b, c, ...)
    "(" <first:TopExpr> "," <rest:Comma<TopExpr>> ")" => {
        let mut elems = vec![first];
        elems.extend(rest);
        Expr::Tuple(elems)
    },
    // Grouping parentheses (single expression)
    "(" <TopExpr> ")",
    // Range: [n] creates array 0..n
    "[" <e:TopExpr> "]" => Expr::Range(Box::new(e)),
    // Array literal: {1, 2, 3}
    r"\{" <elems:Comma<TopExpr>> r"\}" => Expr::Array(elems),
    // Builtin function call or user function call
    <name:Ident> "(" <arg:TopExpr> ")" => {
        let builtins = ["sin", "cos", "tan", "asin", "acos", "atan",
                        "sinh", "cosh", "tanh", "asinh", "acosh", "atanh",
                        "sqrt", "abs", "ln", "log2", "log10", "exp",
                        "floor", "ceil", "round"];
        if builtins.contains(&name) {
            Expr::BuiltinCall(name.to_string(), Box::new(arg))
        } else {
            Expr::Call(name.to_string(), Box::new(arg))
        }
    },
    // Variable reference
    <name:Ident> => Expr::Ident(name.to_string()),
};

Num: Expr = <s:r"[0-9]+(\.[0-9]+)?"> => Expr::Scalar(s.parse().unwrap());

Ident: &'input str = <s:r"[a-zA-Z_][a-zA-Z0-9_]*"> => s;
