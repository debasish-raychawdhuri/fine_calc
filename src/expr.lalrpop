use std::collections::HashMap;
use crate::value::Value;

grammar(vars: &HashMap<String, Value>);

pub TopExpr: Value = {
    <l:TopExpr> "||" <r:AndExpr> => l.or(r),
    AndExpr,
};

AndExpr: Value = {
    <l:AndExpr> "&&" <r:CmpEq> => l.and(r),
    CmpEq,
};

CmpEq: Value = {
    <l:CmpEq> "==" <r:CmpRel> => l.eq_val(r),
    <l:CmpEq> "!=" <r:CmpRel> => l.ne_val(r),
    CmpRel,
};

CmpRel: Value = {
    <l:CmpRel> ">=" <r:Expr> => l.ge(r),
    <l:CmpRel> "<=" <r:Expr> => l.le(r),
    <l:CmpRel> ">" <r:Expr> => l.gt(r),
    <l:CmpRel> "<" <r:Expr> => l.lt(r),
    Expr,
};

Expr: Value = {
    <l:Expr> "+" <r:Factor> => l.add(r),
    <l:Expr> "-" <r:Factor> => l.sub(r),
    Factor,
};

Factor: Value = {
    <l:Factor> "*" <r:Power> => l.mul(r),
    <l:Factor> "/" <r:Power> => l.div(r),
    Power,
};

Power: Value = {
    <base:Unary> "^" <exp:Power> => base.powf(exp),
    Unary,
};

Unary: Value = {
    "-" <Unary> => <>.neg(),
    "!" <Unary> => <>.not(),
    Atom,
};

Comma<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T> => {
        v.push(e);
        v
    }
};

Atom: Value = {
    Num,
    "(" <TopExpr> ")",
    "[" <e:TopExpr> "]" =>? {
        e.range().map_err(|msg| lalrpop_util::ParseError::User { error: msg })
    },
    r"\{" <elems:Comma<TopExpr>> r"\}" =>? {
        let mut scalars = Vec::new();
        for elem in elems {
            match elem.as_scalar() {
                Some(v) => scalars.push(v),
                None => return Err(lalrpop_util::ParseError::User {
                    error: "Array literal elements must be scalars",
                }),
            }
        }
        Ok(Value::Array(scalars))
    },
    <name:Ident> "(" <arg:TopExpr> ")" =>? {
        match name {
            "sin" => Ok(arg.apply_fn(f64::sin)),
            "cos" => Ok(arg.apply_fn(f64::cos)),
            "tan" => Ok(arg.apply_fn(f64::tan)),
            "asin" => Ok(arg.apply_fn(f64::asin)),
            "acos" => Ok(arg.apply_fn(f64::acos)),
            "atan" => Ok(arg.apply_fn(f64::atan)),
            "sinh" => Ok(arg.apply_fn(f64::sinh)),
            "cosh" => Ok(arg.apply_fn(f64::cosh)),
            "tanh" => Ok(arg.apply_fn(f64::tanh)),
            "asinh" => Ok(arg.apply_fn(f64::asinh)),
            "acosh" => Ok(arg.apply_fn(f64::acosh)),
            "atanh" => Ok(arg.apply_fn(f64::atanh)),
            "sqrt" => Ok(arg.apply_fn(f64::sqrt)),
            "abs" => Ok(arg.apply_fn(f64::abs)),
            "ln" => Ok(arg.apply_fn(f64::ln)),
            "log2" => Ok(arg.apply_fn(f64::log2)),
            "log10" => Ok(arg.apply_fn(f64::log10)),
            "exp" => Ok(arg.apply_fn(f64::exp)),
            "floor" => Ok(arg.apply_fn(f64::floor)),
            "ceil" => Ok(arg.apply_fn(f64::ceil)),
            "round" => Ok(arg.apply_fn(f64::round)),
            _ => {
                if let Some(Value::Lambda { param, body }) = vars.get(name) {
                    let mut inner = vars.clone();
                    inner.insert(param.clone(), arg);
                    crate::expr::TopExprParser::new()
                        .parse(&inner, body)
                        .map_err(|_| lalrpop_util::ParseError::User { error: "Lambda evaluation failed" })
                } else {
                    Err(lalrpop_util::ParseError::User {
                        error: "Unknown function",
                    })
                }
            },
        }
    },
    <name:Ident> =>? {
        match name {
            "pi" => Ok(Value::Scalar(std::f64::consts::PI)),
            "e" => Ok(Value::Scalar(std::f64::consts::E)),
            _ => {
                if let Some(val) = vars.get(name) {
                    Ok(val.clone())
                } else {
                    Err(lalrpop_util::ParseError::User {
                        error: "Unknown identifier",
                    })
                }
            }
        }
    },
};

Num: Value = <s:r"[0-9]+(\.[0-9]+)?"> => Value::Scalar(s.parse().unwrap());

Ident: &'input str = <s:r"[a-zA-Z_][a-zA-Z0-9_]*"> => s;
