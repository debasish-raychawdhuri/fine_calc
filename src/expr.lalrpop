use crate::ast::{Expr, BinOp, UnaryOp, Span, Spanned, SpannedExpr};

grammar;

pub TopExpr: SpannedExpr = {
    <l:@L> <left:TopExpr> "||" <right:AndExpr> <r:@R> => {
        Spanned::new(Expr::BinOp(Box::new(left), BinOp::Or, Box::new(right)), Span::new(l, r))
    },
    AndExpr,
};

AndExpr: SpannedExpr = {
    <l:@L> <left:AndExpr> "&&" <right:CmpEq> <r:@R> => {
        Spanned::new(Expr::BinOp(Box::new(left), BinOp::And, Box::new(right)), Span::new(l, r))
    },
    CmpEq,
};

CmpEq: SpannedExpr = {
    <l:@L> <left:CmpEq> "==" <right:CmpRel> <r:@R> => {
        Spanned::new(Expr::BinOp(Box::new(left), BinOp::Eq, Box::new(right)), Span::new(l, r))
    },
    <l:@L> <left:CmpEq> "!=" <right:CmpRel> <r:@R> => {
        Spanned::new(Expr::BinOp(Box::new(left), BinOp::Ne, Box::new(right)), Span::new(l, r))
    },
    CmpRel,
};

CmpRel: SpannedExpr = {
    <l:@L> <left:CmpRel> ">=" <right:Additive> <r:@R> => {
        Spanned::new(Expr::BinOp(Box::new(left), BinOp::Ge, Box::new(right)), Span::new(l, r))
    },
    <l:@L> <left:CmpRel> "<=" <right:Additive> <r:@R> => {
        Spanned::new(Expr::BinOp(Box::new(left), BinOp::Le, Box::new(right)), Span::new(l, r))
    },
    <l:@L> <left:CmpRel> ">" <right:Additive> <r:@R> => {
        Spanned::new(Expr::BinOp(Box::new(left), BinOp::Gt, Box::new(right)), Span::new(l, r))
    },
    <l:@L> <left:CmpRel> "<" <right:Additive> <r:@R> => {
        Spanned::new(Expr::BinOp(Box::new(left), BinOp::Lt, Box::new(right)), Span::new(l, r))
    },
    Additive,
};

Additive: SpannedExpr = {
    <l:@L> <left:Additive> "+" <right:Multiplicative> <r:@R> => {
        Spanned::new(Expr::BinOp(Box::new(left), BinOp::Add, Box::new(right)), Span::new(l, r))
    },
    <l:@L> <left:Additive> "-" <right:Multiplicative> <r:@R> => {
        Spanned::new(Expr::BinOp(Box::new(left), BinOp::Sub, Box::new(right)), Span::new(l, r))
    },
    Multiplicative,
};

Multiplicative: SpannedExpr = {
    <l:@L> <left:Multiplicative> "**" <right:Power> <r:@R> => {
        Spanned::new(Expr::BinOp(Box::new(left), BinOp::TensorProduct, Box::new(right)), Span::new(l, r))
    },
    <l:@L> <left:Multiplicative> "*" <right:Power> <r:@R> => {
        Spanned::new(Expr::BinOp(Box::new(left), BinOp::Mul, Box::new(right)), Span::new(l, r))
    },
    <l:@L> <left:Multiplicative> "/" <right:Power> <r:@R> => {
        Spanned::new(Expr::BinOp(Box::new(left), BinOp::Div, Box::new(right)), Span::new(l, r))
    },
    Power,
};

Power: SpannedExpr = {
    <l:@L> <base:Unary> "^" <exp:Power> <r:@R> => {
        Spanned::new(Expr::BinOp(Box::new(base), BinOp::Pow, Box::new(exp)), Span::new(l, r))
    },
    Unary,
};

Unary: SpannedExpr = {
    <l:@L> "-" <u:Unary> <r:@R> => {
        Spanned::new(Expr::UnaryOp(UnaryOp::Neg, Box::new(u)), Span::new(l, r))
    },
    <l:@L> "!" <u:Unary> <r:@R> => {
        Spanned::new(Expr::UnaryOp(UnaryOp::Not, Box::new(u)), Span::new(l, r))
    },
    Postfix,
};

Postfix: SpannedExpr = {
    <l:@L> <base:Postfix> "[" <idx:TopExpr> "]" <r:@R> => {
        Spanned::new(Expr::Index(Box::new(base), Box::new(idx)), Span::new(l, r))
    },
    // Fold: array @ init { lambda }
    <l:@L> <arr:Postfix> "@" <init:Unary> r"\{" <lam:TopExpr> r"\}" <r:@R> => {
        Spanned::new(Expr::Fold { array: Box::new(arr), init: Box::new(init), lambda: Box::new(lam) }, Span::new(l, r))
    },
    Atom,
};

Comma<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T> => {
        v.push(e);
        v
    }
};

CommaSep<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T?> => match e {
        Some(e) => { let mut v = v; v.push(e); v }
        None => v
    }
};

Atom: SpannedExpr = {
    Num,
    // Lambda: |x|(body) - single param
    <l:@L> "|" <p:Ident> "|" "(" <body:TopExpr> ")" <r:@R> => {
        Spanned::new(Expr::Lambda { params: vec![p.to_string()], body: Box::new(body) }, Span::new(l, r))
    },
    // Lambda: |x,y|(body) - multi param (2+)
    <l:@L> "|" <first:Ident> "," <rest:Comma<Ident>> "|" "(" <body:TopExpr> ")" <r:@R> => {
        let mut params = vec![first.to_string()];
        params.extend(rest.iter().map(|s| s.to_string()));
        Spanned::new(Expr::Lambda { params, body: Box::new(body) }, Span::new(l, r))
    },
    // Tuple literal: (a, b) or (a, b, c, ...)
    <l:@L> "(" <first:TopExpr> "," <rest:Comma<TopExpr>> ")" <r:@R> => {
        let mut elems = vec![first];
        elems.extend(rest);
        Spanned::new(Expr::Tuple(elems), Span::new(l, r))
    },
    // Grouping parentheses (single expression) - pass through with preserved span
    "(" <e:TopExpr> ")" => e,
    // Range: [n] creates array 0..n
    <l:@L> "[" <e:TopExpr> "]" <r:@R> => {
        Spanned::new(Expr::Range(Box::new(e)), Span::new(l, r))
    },
    // Array literal: {1, 2, 3}
    <l:@L> r"\{" <elems:Comma<TopExpr>> r"\}" <r:@R> => {
        Spanned::new(Expr::Array(elems), Span::new(l, r))
    },
    // Builtin function call or user function call
    <l:@L> <name:Ident> "(" <arg:TopExpr> ")" <r:@R> => {
        let builtins = ["sin", "cos", "tan", "asin", "acos", "atan",
                        "sinh", "cosh", "tanh", "asinh", "acosh", "atanh",
                        "sqrt", "abs", "ln", "log2", "log10", "exp",
                        "floor", "ceil", "round"];
        if builtins.contains(&name) {
            Spanned::new(Expr::BuiltinCall(name.to_string(), Box::new(arg)), Span::new(l, r))
        } else {
            Spanned::new(Expr::Call(name.to_string(), Box::new(arg)), Span::new(l, r))
        }
    },
    // Variable reference
    <l:@L> <name:Ident> <r:@R> => {
        Spanned::new(Expr::Ident(name.to_string()), Span::new(l, r))
    },
};

Num: SpannedExpr = <l:@L> <s:r"[0-9]+(\.[0-9]+)?"> <r:@R> => {
    Spanned::new(Expr::Scalar(s.parse().unwrap()), Span::new(l, r))
};

Ident: &'input str = <s:r"[a-zA-Z_][a-zA-Z0-9_]*"> => s;
